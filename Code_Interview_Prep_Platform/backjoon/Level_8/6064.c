// 최근에 ICPC 탐사대는 남아메리카의 잉카 제국이 놀라운 문명을 지닌 카잉 제국을 토대로 하여 세워졌다는 
// 사실을 발견했다. 카잉 제국의 백성들은 특이한 달력을 사용한 것으로 알려져 있다. 
// 그들은 M 과 N 보다 작거나 같은 두 개의 자연수 x, y를 가지고 각 년도를 <x:y>와 같은 형식으로 표현하였다. 
// 그들은 이 세상의 시초에 해당하는 첫 번째 해를 <1:1>로 표현하고, 두 번째 해를 <2:2>로 표현하였다.
//  <x:y>의 다음 해를 표현한 것을 <x':y'>이라고 하자. 
//  x < M 이면 x' = x + 1이고, 그렇지 않으면 x' = 1이다. 
//  y < N이면 y' = y + 1이고, 그렇지 않으면 y' = 1이다. 
 // <M:N>은 그들 달력의 마지막 해로서, 이 해에 세상의 종말이 도래한다는 예언이 전해 온다. 

// 예를 들어, M = 10 이고 N = 12라고 하자. 첫 번째 해는 <1:1>로 표현되고, 
 // 11 번째 해는 <1:11>로 표현된다. <3:1>은 13 번째 해를 나타내고,
  // <10:12>는 마지막인 60 번째 해를 나타낸다. 
// 네 개의 정수 M, N, x 와 y가 주어질 때,
 // <M:N>이 카잉 달력의 마지막 해라고 하면 <x:y>는 몇 번째 해를 나타내는 지를 구하는 프로그램을 작성하라. 
// case1=> M=10 N=12 <1:1> <2:2><3:3>...<10:10><1:11>(11 more than M)<2:12><3:1>(y=12!<N)
/*
 달력의 총 갯수는 M과 N의 최소 공배수이다.

*/
/*
case1
if 4,7
	M=10 N=12
1 -> 1 11 9  7  5  3
2 -> 2 12 10 8  6  4
3 -> 3 1  11 9  7  5
4 -> 4 2  12 10 8  6
5 -> 5 3  1  11 9  7
6 -> 6 4  2  12 10 8
7 -> 7 5  3  1  11 9
8 -> 8 6  4  2  12 10
9 -> 9 7  5  3  1  11
10->10 8  6  4  2  12

case2
M=10 N=11
1  -> 1 11 10 9  8  7
2  -> 2  1 11 10 9  8
3  -> 3  2  1 11 10 9
4  -> 4  3  2  1 11 10
5  -> 5  4  3  2 1  11
6  -> 6  5  4  3 2  1
7  -> 7  6  5  4 3  2
8  -> 8  7  6  5 4  3
9  -> 9  8  7  6 5  4
10 ->10  9  8  7 6  5

case3
M=11 N=4
1   4   
2     4 
3       4
4 4     
5   4   
6     4 
7       4
8 4     
9   4   
10    4  
11      4


case4
M=2 N=2
1 ->1
2 ->2
case5
M=3 N=1
11
11
31

case6
M=3 N=4
1 ->1 4 3 2
2 ->2 1 4 3
3 ->3 2 1 4

case7
M=4 N=2
1 ->1
2 ->2 
3 ->1 
4 ->2

case8
M=4  N=3
1 -> 1 2 3
2 -> 2 3 1
3 -> 3 1 2
4 -> 1 2 3

case9
M=4 N=5
1 -> 1 5 4 3 2
2 -> 2 1 5 4 3
3 -> 3 2 1 5 4 
4 -> 4 3 2 1 5

case10
M=4 N=6
1 -> 1 5 3 
2 -> 2 6 4
3 -> 3 1 5
4 -> 4 2 6

case11
M=4 N=7
1 -> 1 5 2 6 3 7 4
2 -> 2 6 3 7 4 1 5
3 -> 3 7 4 1 5 2 6
4 -> 4 1 5 2 6 3 7

case12
M=4 N=8
1 -> 1 5
2 -> 2 6
3 -> 3 7
4 -> 4 8

case13
M=4 N=10
1 -> 1 5 9  3 7
2 -> 2 6 10 4 8
3 -> 3 7 1  5 9
4 -> 4 8 2  6 10

case14
M=5 N=3
1 -> 1 3 2 
2 -> 2 1 3
3 -> 3 2 1 
4 -> 1 3 2
5 -> 2 1 3

case15
M=7 N=4
1 -> 1 4 3 2
2 -> 2 1 4 3
3 -> 3 2 1 4
4 -> 4 3 2 1
5 -> 1 4 3 2
6 -> 2 1 4 3
7 -> 3 2 1 4

case16
M=6 N=2
1 1
2 2
3 1
4 2
5 1
6 2

case17
M=6 N=4
1 1 3
2 2 4
3 3 1
4 4 2
5 1 3
6 2 4

이걸 보면 둘의 최소 공배수는 8이다 그러니 총 갯수는 8개
M=8 N=4
1
2
3
4
5
6
7
8

툴의 최소 공배수는 20이다 그러니 총 갯수는 20개 이다.
M=10 N=4
1 -> 1 3    
2 -> 2 4
3 -> 3 1
4 -> 4 2
5 -> 1 3
6 -> 2 4
7 -> 3 1
8 -> 4 2
9 -> 1 3
10-> 2 4


1. 총개수는 최소공배수
	문제를 보면 M과 N의 조합으로 만들어지는 달력의 총 갯수의 관계는 최소공배수 관계이다.
2. 총 사이클수는 최소공배수/N
	M의 최대와 N의 최대에 도달했을때를 한 사이클이라고 했을때, 총개수는 최소공배수 값이고
	한 사이클은 최소공배수 /N이 된다.
풀이법 : 총 개수와 총 사이클수를 구할수 있다. 처음 시작하는 x,y를 찾고 그다음 x,y를 찾았을때는
두사이클 째 이다. 이런식으로 최대 사이클에 도달했는데도 x,y를 못찾는 다면 -1리턴
3. 다음 사이클의 예상 x값 즉 x+N=<M 이면 x+N, x+N>M 이면 (x+N)%M이다.
	case11을 보면 M=4 N=7이다.내가 찾고자 하는 값이 3,7이라고 해보자 그럼 한사이클후 그다음번
	7이 나오는 곳은 3+7/4의 나머지 이다. 즉, (x+N)%N임.
	근데 이런 경우가 있음 case1 처럼 M=10 N=12일떄 x=10 y=12를 찾는다 해보자.
	이미 결과를 알고 있지만 60번째에 등장해야한다.
위의 예시들을 보면 알수 있다.


가장 간단하게는 x,y에 1씩 더하는 방법인데 시간 초과임. 
최대가 40000 40000이니까 최대 16억년이 계산됨
그럼 각 x,y를 더하는 연산은 32억번임.
*/
#include <stdio.h>
int GCD();
int LCM();
int total_cycle();
int next_value();
int what_day();


int main(){
	int test=0;
	int M,N,x_M,y_N;
	scanf("%d",&test);

	for (int i = 0; i < test; ++i)
	{
		scanf("%d %d %d %d",&M,&N,&x_M,&y_N);
		printf("%d\n",what_day(M,N,x_M,y_N));
	}

}

int GCD(int a,int b){ //최대공약수
	while(b!=0){
		int r = a%b;
		a= b;
		b= r;
	}
	return a;

}

int LCM(int a, int b){ //최소공배수
	return a * b / GCD(a,b);
}

int total_cycle(int lcm,int N){
	return lcm/N;

}
int next_value(int x,int M,int N){
	if(x+N>M){
		if((x+N)%M==0){
			return M;
		}
		return (x+N)%M;
	}
	else
		return x+N;
	
}
int what_day(int M,int N,int x,int y){
	int total_year,temp_year;
	int temp_y=1,temp_x=1;
	int first_x=0,first_y=0;
	int max_cycle=0,temp_cycle=0;
	max_cycle=total_cycle(LCM(M,N),N);
	// total_year=LCM(M,N); 총 년수
	while(temp_y!=y){
		if(temp_x<M)
			temp_x++;
		else
			temp_x=1;
		
		if(temp_y<N)
			temp_y++;
		else
			temp_y=1;

	}

	while(1){
		if(temp_x==x&&temp_cycle<=max_cycle){
			return temp_cycle*N+y;
		}

		if(temp_cycle>max_cycle){
			return -1;
		}

		else{
			temp_x=next_value(temp_x,M,N);
			temp_cycle++;
		}

	}

}